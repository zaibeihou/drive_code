复用寄存器(IOMUX)是用来选择这个引脚具体工作在什么功能的。因为在RK3568这样的芯片中，一个物理引脚可以有多个功能。
以GPIO0_B7为例：

复用功能：

GPIO0_B7可能的功能：
- 功能0：普通GPIO（控制LED）
- 功能1：UART信号
- 功能2：I2C信号
- 功能3：其他功能

IOMUX寄存器作用：

通过配置IOMUX寄存器
- 选择引脚工作在哪个功能模式
- 比如要用作LED控制，就要配置为GPIO模式

寄存器配合关系：

要控制LED，需要：
1. IOMUX寄存器：配置为GPIO模式
2. 方向寄存器：配置为输出模式
3. 数据寄存器：控制高低电平
可以理解为：

IOMUX寄存器决定这个引脚"是什么"（GPIO还是其他功能）
方向寄存器决定GPIO的"工作方式"（输入还是输出）
数据寄存器控制GPIO的"具体状态"（高电平还是低电平）

这样的设计让有限的引脚可以实现更多的功能。

在芯片设计中，复用控制（IOMUX）通常被放在 GRF（General Register Files，通用寄存器文件）区域，而不是和 GPIO 控制器放在一起。这样设计有其特定的原因：

功能分区：

GRF区域（0xFDC20000开始）：
- 包含复用控制寄存器
- 包含其他通用配置
- 统一管理芯片的配置功能

GPIO控制器区域（0xFDD60000开始）：
- 只负责GPIO的基本操作
- 包含数据、方向等寄存器
- 专注于GPIO的控制功能

控制流程：

要控制一个LED，完整步骤是：
1. 在GRF中配置引脚复用为GPIO功能
   - 使用GRF中的IOMUX寄存器
   - 地址在GRF区域

2. 然后在GPIO控制器中进行操作
   - 配置方向（使用GPIO控制器的DDR寄存器）
   - 控制电平（使用GPIO控制器的DR寄存器）
   - 地址在GPIO区域
这种设计的好处：

功能分离清晰
便于统一管理配置
提高了系统的灵活性

所以看到复用寄存器和GPIO寄存器基地址不同是正常的，它们属于芯片中不同的功能模块。


GPIO相关寄存器的分布：

GPIO控制器区域 (基地址：0xFDD20000)：

GPIO0_DR（数据寄存器）：
- 基地址 + 0x0000 = 0xFDD60000

GPIO0_DDR（方向寄存器）：
- 基地址 + 0x0004 = 0xFDD60004

GRF区域 (基地址：0xFDC20000)：

GPIO0B_IOMUX（复用寄存器）：
- GRF基地址 + 某个偏移
- 例如：0xFDC20000 + 0x0024
所以：

数据和方向寄存器是相对于GPIO0基地址的偏移
复用寄存器是相对于GRF基地址的偏移


控制LED的完整流程：

假设要控制GPIO0_B7连接的LED：

1. 配置复用（GRF区域）
io -w -4 [GRF_IOMUX地址] [配置值]  // 配置为GPIO模式

2. 配置方向（GPIO区域）
io -w -4 0xFDD60004 [配置值]  // 设置为输出模式

3. 控制电平（GPIO区域）
io -w -4 0xFDD60000 [配置值]  // 控制LED亮灭

实际的电路效果：

写寄存器 ──> 改变电路状态 ──> 影响物理引脚 ──> 控制LED

但在实际开发中：

// 不推荐直接操作寄存器
io -w -4 0xFDD60000 0x1

// 推荐使用标准GPIO接口
gpio_direction_output(gpio_num, 1);
gpio_set_value(gpio_num, 1);
原因是：

直接操作寄存器容易出错
可能与其他程序冲突
不同芯片的寄存器地址不同
标准接口更安全可靠

所以虽然我们可以通过修改内存中的寄存器值来控制硬件，但在实际开发中最好使用标准的驱动框架。
